\documentclass[a4paper, 10pt, american, titlepage]{article}

% useful packages
\usepackage[utf8]{inputenc}
\usepackage{minted}
\usepackage[american]{babel}
\usepackage{csquotes}
\usepackage{graphicx} % for images
\usepackage[gen]{eurosym} % for literally just the euro symbol

\usepackage{lipsum}   % lorem-ipsum placeholder text
\usepackage{bookmark} % links to other parts of the PDF
%\usepackage{minted}
% if we want to use a different style, here are some to look at
% https://www.overleaf.com/learn/latex/Biblatex_bibliography_styles
\usepackage[backend=biber,style=numeric]{biblatex}
\usepackage[page, titletoc, title]{appendix}
\usepackage[margin=1in]{geometry} % set 1in margins
\usepackage{hyperref}      % hyperlinks

% more breathing room
\linespread{1.5}
\setminted{fontsize=\small,baselinestretch=1}

% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor}

% stuff for LaTeX to know
\bibliography{references}
\graphicspath{ {./images/} } % put images in here
\title{Kyoto VR MQP Paper First Draft}
\author{William~Campbell, Cole~Granof, and Joseph~Petitti}
\date{\today}

% call it "Table of Contents" instead of just "Contents"
\addto{\captionsamerican}{\renewcommand*{\contentsname}{Table of Contents}}

\begin{document}

% set page numbers to Roman for the forematter (before the introduction)
\pagenumbering{roman}


\maketitle

\begin{abstract}
\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{abstract.jpg}
	% Note: you don't actually need the part in square brackets for the caption,
	% but if you omit it the regular caption text will be used for the List of
	% Figures entry.
	\caption[\textit{Number 1, 1950 (Lavender Mist)}, Jackson Pollock]
	{\textit{Number 1, 1950 (Lavender Mist)}, Jackson Pollock, National
		Gallery of Art, Washington, D.C.}
	\label{fig:abstract}
\end{figure}
\end{abstract}

\section*{Acknowledgments}
\label{sec:acknowledgements}
\addcontentsline{toc}{section}{Acknowledgments}


\clearpage

\section*{Executive Summary}
\label{sec:executiveSummary}
\addcontentsline{toc}{section}{Executive Summary}


\clearpage

% now comes the table of contents, list of figures, and list of tables
% these should be single spaced
{
\linespread{1}

% add table of contents to itself
\tableofcontents
\addcontentsline{toc}{section}{Table of Contents}
\newpage

\listoffigures
\addcontentsline{toc}{section}{List of Figures}
\newpage

% we don't have any tables yet, but uncomment this when we do
%\addcontentsline{toc}{section}{List of Tables}
%\listoftables
%\newpage
}

% go back to 1.5 spacing and Arabic numbering for the rest of the paper
\pagenumbering{arabic}

\section{Introduction}
\label{sec:introduction}

\section{Background}
\label{sec:background}

As smartphones and mobile technology become more prevalent,
new forms of human-computer interaction are becoming mainstream. Smartphones
allow for an unprecedented degree of connectivity with the digital world, but
can also serve as a tool for enhancing the physical world. In this section we
explain the origins and uses of some of this technology.

\subsection{What is Augmented Reality?}
\label{sec:whatIsAugmentedReality}

Augmented Reality, or AR, is a type of human-computer interface where
perceptions of the real world are enhanced by computer-generated information.
This differs from Virtual Reality (VR) in that a VR experience consists
exclusively of virtual information. In AR, virtual information is mixed with
sensory input from the real world~\autocite{carmigniani2011}. This can enhance
the user's perception of reality by providing information that would be
difficult or impossible to display through traditional means.

For example, AR can be used to display information about historical events,
places, and objects overlaid onto images of the real world~\autocite{saenz2009}.
This provides the user with useful information without needing to alter the real
historic site.

\subsection{Current Augmented Reality Technology}
\label{sec:currentAugmentedRealityTechnology}

While preparing for this project our team researched the current state of
augmented reality technology. Smartphones are the most commonly used AR
hardware by far [citation needed]. Typically smartphone AR applications make
use of the phone's camera, accelerometer, gyroscope, and GPS sensors to
reproduce a view of the real world with virtual information layered on top of
it~\autocite{bonsor2018}.

\subsection{Augmented Reality Use Cases}
\label{sec:augmentedRealityUseCases}

Even though it is still a developing technology, augmented reality has been used
in many disparate disciplines, including data
visualization~\autocite{resnick2017}, commerce~\autocite{matney2018},
marketing~\autocite{sharma2015}, education~\autocite{stewart-smith2012}, visual
art~\autocite{katz2018}, and even archaeology~\autocite{eve2012}.

The video game industry has readily embraced augmented reality, leading to the
development of many AR games for smartphones and dedicated head-mounted
displays. Perhaps the most popular AR game, \textit{Pokémon Go}, has been
downloaded over a billion times~\autocite{webster2018}. This game makes use of
GPS and camera data to overlay game objects (in this case fictional monsters) on
top of images of the real world~\autocite{concepcion2016} (see Figure
\ref{fig:pokemonGo}).

\begin{figure}[h]
	\centering
	\includegraphics[width=.5\textwidth]{pokemon-go.jpg}
	\caption[A screenshot from the AR game \textit{Pokémon Go}]{A screenshot
		from the AR game \textit{Pokémon Go}~\autocite{vastateparks2016}.}
	\label{fig:pokemonGo}
\end{figure}

\subsection{Challenges of Augmented Reality}
\label{sec:challengesOfAugmentedReality}

As we have said, AR is a new and growing field full of opportunities. But of course,
as with anything new, our understanding of AR and how to develop for it is limited.
And with those limitations come challenges. All sorts of different challenges and
limitations face the development and production of AR apps. Here are some that
we considered when working on our app.

Many of the applications and use cases that exist for AR right now are, simply put,
not very good. This means a few different things. For starters, many AR apps and
features available on smartphones offer very little in the way of functionality or
practicality; quite simply, they are primarily used for minor spectacles and simple
tricks~\autocite{theappsolutions2018}. For example, one of the most popular apps
to use AR, Pokemon GO, primarily uses it's AR feature to place a Pokemon in the
world aroudn you through your phone camera for you to capture. But when it is in
the world, it does not interact with anything around it. It just floats a fixed distance
away from you, simply placed on top of your camera's video feed. 

Additionally, in many cases where AR is used, the task could be accomplished as well 
or better without AR~\autocite{theappsolutions2018}. Returning to the Pokemon GO
example, when the AR feature is left on while capturing a Pokemon, the extra power
needed for this feature drains the device faster, makes it harder to hit the Pokemon
with a Pokeball due to the model drifting in the environment, and can even slow app
performance, all of which detract from the ability to play and enjoy the game. 

One of the major problems facing AR development as a whole, and one that we
ran into as well, is limited hardware. For starters, smartphone cameras present
a major limitation. Many smartphone cameras only capture images in 2D, which can
make generating AR content in a 3D world difficult without the use of QR or barcode
markers~\autocite{geospatialworld2018}. Additionally, GPS sensors on smartphones
can also be too imprecise for good AR tracking~\autocite{geospatialworld2018}.

The biggest hardware limitation comes from which platform to use. AR apps are most
commonly designed for smartphones due to their relatively low cost and how accessible
they are. But, as we just discussed, smartphones come with a host of hardware
limitations that make achieving satisfying AR capabilities difficult. Additionally, AR apps
for smartphones tend not to be very user-friendly, and oftentimes even complicate
the task or activity they were meant to enhance~\autocite{theappsolutions2018}.
The alternative then is to turn to dedicated hardware, like Microsoft's HoloLens. 
But dedicated hardware like the HoloLens is very inaccessible and expensive; 
Microsoft only offers developer editions of the HoloLens, and for the incredibly steep 
price of \$3,500~\autocite{microsoft2019}. 

The challenges we faced during development mirrored these that plague the industry
as a whole very accurately. We struggled with how exactly we would us AR for our app
in a way that benefit the experience as a whole, but believe the way we've implemented
it will enhance the user's experience. Hardware issues were definitely our biggest challenge.
Only one of our phones is new enough to run AR technology at a decent level, making
testing of our application difficult.  

\subsection{Apps for Art and Culture}
\label{sec:appsForArtAndCulture}

To explore existing AR apps for art and culture our group researched and tested
several games, experiences, and platforms related to our project.

\subsubsection{izi.TRAVEL}
\label{sec:iziTravel}

Before our project started, Kyoto VR was already using an app with a limited
form of AR for tours. The app, called izi.TRAVEL, allows users to create audio
tours with audio and image files tied to specific locations in the real
world~\autocite{izitravel2015} (see Figure \ref{fig:iziTravel}). The app is
aimed at museums and city tours~\autocite{izitravel}, but can be used for tours
of historic sites too.  Kyoto VR used the platform to make an audio tour of
Kinkaku-ji, one of the most popular tourist destinations in
Japan~\autocite{bornoff2000} and an important historic heritage
site~\autocite{unesco}.


\begin{figure}[h]
	\centering
	\includegraphics[width=.5\textwidth]{izi-travel.jpg}
	\caption{A screenshot of the izi.TRAVEL app interface}
	\label{fig:iziTravel}
\end{figure}

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{kinkakuji.jpg}
	\caption[The Golden Pavilion of Kinkaku-ji, Kyoto, Japan]{The Golden
		Pavilion of Kinkaku-ji, Kyoto, Japan~\autocite{davidson2005}}
	\label{fig:kinkakuji}
\end{figure}

By using GPS data from the user's phone to play audio and display images at
specific places in the real world izi.TRAVEL uses a limited form of augmented
reality. Our group aimed to implement and extend this functionality in our own
app. See Section \ref{sec:aruku} for more details.

\subsection{Platforms}
\label{sec:platforms}

Before we could start working on creating our app, we first needed to decide which
AR development platform to use. Our preliminary research had shown us that there
are so many different platforms out there, all of which have been used to create
great AR apps. There were a lot of things we needed to consider before finalizing
on a platform, like what features it offered, which devices and operating systems the
app could run on, and definitely the cost. Detailed below are some of the different
platforms we considered.

\subsubsection{ARCore and ARKit}
\label{sec:ARCoreAndARKit}

ARKit and ARCore are both AR frameworks that enable apps to take advantage of
powerful AR related features. ARKit is developed by Apple and can only be used
by iPhones. Google's ARCore framework can deploy to both Android and iPhone.
Many cross platform solutions will leverage the full potential of their target
platform by using either ARKit or ARCore ``under the hood''. Both ViroReact and
Vuforia use ARKit or ARCore depending on the target platform
\autocites{vuforiaFusion}{moon2018}.

ARKit 3 aims to support a wide array of new features, and will be available in
iOS 13. Notably, one of these features is ``people occlusion,'' which will allow
virtual objects to be realistically obscured when someone walks in front of the
object~\autocite{apple2019}. This kind of technology could be useful for us
since our app uses AR in crowded places.  As of August, 2019, this feature is
not on the horizon for Google's Android AR framework, ARCore.

Both ARKit and ARCore have well-supported APIs for Unity. ARKit 3 support is
coming to Unity, along with all of the advanced features that it
brings~\autocite{stinson2019}.

\subsubsection{Wikitude}
\label{sec:wikitude}

// TODO: Need a way to add Euro character to document; the way they are in now doesn't work

Wikitude is another major AR development kit that is very prevalent in the world
of AR development. It has over 130,000 registered AR developers, and is powering
over 30,000 AR apps across smartphones, tablets, and smart glasses~\autocite{wikitude2018}.
And it's easy to understand why Wikitude has so many registered developers
when you see the list of features it offers. Some of the features that appealed
most to us were their Instant Tracking, allowing for augmentation using flat surfaces;
Image Tracking, allowing for augmentation using one or multiple 2D images; and
Geo AR, allowing for creation of geo markers at specific locations to triggered AR
content~\autocite{wikitude2018}. 

Wikitude also supports all sorts of different platforms. It supports Android, Apple,
and Windows phones and tablets, as well as smart glasses like the Epson Moverio,
Microsoft Hololens, and Vuzix smart glasses~\autocite{wikitude2018}. Additionally,
many different development frameworks are capable of running Wikitude's SDK.
According to Wikitude's website, their SDK works with Windows, Android, and iOS
development frameworks, as well as ARCore and ARKit, Flutter, Cordova, Xamarin,
and even Unity~\autocite{wikitude2018}. 

From all of this information, Wikitude certainly sounds like a fantastic AR development
platform; it certainly did to us. But the issue we ran into was the cost. Wikitude is, in
fact, free for eligible startups, but given the criteria they list on their site, we were not
confident that we would qualify. Aside from this option, Wikitude offers a 30-day demo
license for \euro{499}, which is a lot for use to pay for a license that would not even last for
our entire project. They also charge \euro{1990} for their SDK Pro, and \euro{2490} for their
SDK Pro 3D~\autocite{wikitude2018}. Given these prices, and our very limited budget
of \$0, we knew that we would have to pass on Wikitude and choose a different AR
development platform. 

\subsubsection{KudanSlam}
\label{sec:kudanSlam}

\subsubsection{motive.io}
\label{sec:motive.io}

\subsubsection{Viro AR}
\label{sec:viroAR}

Viro AR comes in two flavors: ViroReact and ViroCore. ViroCore allows
developers to build an AR Application with Java. The disadvantage of this is
that ViroCore only allows developers to target Android, which unfortunately
made ViroCore not an option for our project. ViroReact is the cross-platform
option for ViroAR. ViroReact leverages the cross-platform capabilities of
React, which is Facebook's Javascript Library for developing user
interfaces~\autocite{facebook2019}.

Since our project is not a game, we initially wanted to avoid using a
fully-featured game engine. Therefore, we decided to take the time to explore
this framework since it appeared to be more tailored to our specific use case.
Viro Media also recognizes that all developers who wish to create an app with
3D capabilities are not necessarily game developers. Viro Media pitches Viro
AR as ``The perfect alternative to specialized game engines, ViroAR is a
platform for rapidly building ARKit and ARCore apps. Our platform allows
developers to focus on what they do best by leveraging familiar tools and
frameworks used in mobile application development''~\autocite{viro2019}.
While the majority of our team has decent experience with writing Javascript,
we all either have very little or no experience writing React apps.

In most development scenarios, every time you wish to test your app on actual
hardware, you must first compile your app using either Xcode or Android Studio
depending on your platform. Once you have built the app, your device needs to
install the app. This process can be very time consuming, especially since
frequent tests on real hardware is important for something as intensive as
AR.

An alternative to building your app is to run your app through an emulator on
the computer you are using for development [citation needed on what an emulator
is]. Since an emulator uses software to emulate hardware, this poses two
technical issues that prevent emulators from being a proper replacement for
testing on real hardware.  Emulation is often imperfect, so glitches often
emerge in emulation that do not manifest on the actual hardware [citation
needed about emulator inaccuracies]. Secondly, (and most importantly for AR,)
it is common for emulation to be much slower compared to real hardware.

ViroReact offers a convenient ``test bed'' for rapidly testing your ViroReact
app on native hardware. In the root directory of your project, you can launch
a Node server with the command \texttt{npm start}. From here, you can input
the provided URL into the Viro Media app. This will quickly download the code,
graphics and 3D object files from the server and launch a functional version
of the app \autocite{viro-testbed2019}. This allowed us to get a real AR app
up and running on our devices much more easily than any of the other
frameworks/engines we explored. Unfortunately, the test bed app was somewhat
unreliable based on our experience; the test bed would frequently crash,
or would not be able to download the files from the Node server. The most
reliable way to test our app was to compile a binary and manually install it
onto our devices, which completely defeats the purpose of the test bed app.

\subsubsection{Unity}
\label{sec:unity}

\section{Implementation and Technology}
\label{sec:implementationAndTechnology}

\subsection{Editour: The Tour Editor}
\label{sec:editour}

The goal of Editour is to allow a non-technical user to design audio tours
through a web-app. At its core, Editour is a tool to draw arbitarily-shaped
geographic regions onto a map. An audio file and multiple image files can be
uploaded for each region the user defines. After naming and uploading the tour
with the ``Upload'' button, our backend builds a zip containing a folder that can
be placed directly into the Unity project.

Our backend allows users to save their tours to our server, and load those same
tours back into the editor to resume work.  The geographic area of each region
can be adjusted by clicking and dragging. Vertices can also be added and
deleted if the needs of the tour change over time.

\subsubsection{The Need for an Editor}

One of the goals for our project is to create a working prototype that others
can build off of in the future [citation needed for personal communication].

Similar to the app izi.TRAVEL discussed in section~\ref{sec:iziTravel}, we
needed some way to easily define arbitrary polygons (which we call ``regions'')
and associate media with each one, such as audio and image files.

For testing purposes, we initially defined these regions directly in the C\#
Scripts, hard-coding the coordinates. [citation needed for source used to
write polygon detection code] Below is an example of a quadrilateral
surrounding the Creation Core building at the Ritsumeikan Biwako-Kusatsu
campus.

\begin{minted}{csharp}
Regions.add(new GPSPolygon(new List<GPSPoint>{
    new GPSPoint(34.979222, 135.963628),
    new GPSPoint(34.979187, 135.965130),
    new GPSPoint(34.979794, 135.965053),
    new GPSPoint(34.979754, 135.963669)
}, "Creation Core"));
\end{minted}

Even with knowledge of C\# and Unity, inputing tour data this way is obviously
not convenient. Atticus reminded us that, although he has a working knowledge
of Unity, he is not a software developer [citation needed for personal
communication.] In order to make our app prototype at all useful for the
future, we needed to provide an easy way to ``design'' a tour.

\subsubsection{A Complete Tour Definition}
\label{sec:tourDefinition}

In order to create a fully-functional editor for designing and exporting
``tours,'' we had to consider how to fully define a tour purely in terms
of text and a directory of associated media.

Here is an example of the JSON metadata generated by Editour:

\begin{minted}{json}
{
   "regions": [
      {
         "name": "Beautiful Place",
         "points": [ {"lat": 23.4, "lng": 56.7}, /* list omitted for brevity */ ],
         "audio": [ "beautiful-audio.mp3" ],
         "images": [ "mountain.jpg", "stream.jpg" ]
      },
      {
         "name": "Gorgeous Place",
         "points": [ {"lat": 12.3, "lng": 45.6}, /* list omitted for brevity */ ],
         "audio": [ "gorgeous-audio.mp3" ],
         "images": [ "hill.jpg", "valley.jpg", "gorge.jpg" ]
      }
   ]
}
\end{minted}

Within each object in the region list, we can see that the region has four
properties: a name, a list of coordinates, a list of audio files, and a list of
multiple image files. (In the current design of the app, it only makes sense to
associate one audio file per region, but the format makes it easy to
accommodate for multiple audio files in the future.) One disadvantage is that
all media files have to have unique names. This is because the zip that is
created by the editour backend contains all of the media files in a flat file
structure. The above JSON is used to associate each media file with a region,
meaning that the filename needs to act as a primary key. The backend will
respond with a message if this is the case, prompting the user to have unique
names for all files.

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{editour.jpg}
	\caption{A screenshot of the Editour web app frontend}
	\label{fig:editour}
\end{figure}

\subsubsection{Editour Backend}
\label{sec:editourBackend}

The server-side backend of the Editour application is written in JavaScript for
Node.js. This backend both serves the static frontend content and runs
server-side scripts that process incoming API requests.  We chose Node.js as the
server-side framework because of our prior experience with JavaScript, its
high-performing asynchronous architecture~\autocite{orsini2013}, and its ease of
development.

When a user submits new tour from the web application, the files and metadata
are sent to the server running the Node.js scripts, which zips up the files and
saves them to the server's disk with a timestamp. Then any application can
request a particular tour and the backend will serve the most recent version of
it.

Additionally, our web application allows users to edit existing tours. When the
user requests to edit a tour on the frontend it sends a request to the backend
server for that tour's metadata file. This file contains information about all
regions and files in the tour. The user can then edit the regions, change names,
upload new files, or delete existing ones without ever having to download the
other tour files from the server, which could take a long time depending on
their size. When the user is done editing they can upload the new metadata and
any newly added files to the server, which intelligently collects new and old
files required by the tour and zips them into a new tour file on the disk.


\subsubsection{Future of Editour}
\label{sec:futureOfEditour}

In the current implementation, the tour file generated by the Editour backend
still has to be moved manually to the Unity project folder. In the future, we
would like the app to be able to contact our Editour server and update the tour
info by itself. This would allow Kyoto VR to update the tours without updating
the entire app.

The design of the Editour is agnostic about how the media will be used.  For
an app like izi.TRAVEL, the images are displayed when the associated audio
tour is playing. For ARuku, images can be placed onto the ground plane by the
user, which is unique compared to other audio tour guide apps. The tour files
produced by Editour could theoretically be used by a tour guide app that does
not incorporate AR. 

\subsection{ARuku}
\label{sec:aruku}

\section{Testing}
\label{sec:testing}

See Figure~\ref{fig:turtleBurger} for more details.

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{turtle-burger.jpg}
	\caption[A rare but delicious turtle burger in the wild]{A rare but
		delicious turtle burger in the wild~\autocite{harvey2002}.}
	\label{fig:turtleBurger}
\end{figure}

\section{Conclusion}
\label{sec:conclusion}

\clearpage % references should be on their own page

\printbibliography
\addcontentsline{toc}{section}{References}

\newpage

\appendices
\section{Proof of the First Zonklar Equation}
Appendix one text goes here.

\section{}
Appendix two text goes here.

\end{document}


